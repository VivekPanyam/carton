These bindings allow users to use Carton from C.

A C interface is implemented in Rust in `src/` and a C header file is autogenerated by `cbindgen` in `build.rs`.

See the `.c` files in `tests/` for complete examples of usage.

## Details on async

A large portion of Carton's interface is async and we want to expose this functionality to C. A common approach for async tasks in C is defining functions that accept a callback along with an opaque user provided argument. This callback is later executed with the argument on an internal library-owned thread when the async work is complete.

In our case, these callbacks are executed from within an async task on Tokio-managed threads. As a general rule, it's important to avoid doing blocking I/O or extended periods of CPU-bound work within an async task. Doing so could block other tasks in the runtime from executing.

To help ease these restrictions, we provide `CartonAsyncNotifier`. This lets users wait for or poll for new callbacks on a thread they control, removing the above restrictions and making basic C integrations simpler.

See `tests/notifier.c` for an example.

See the [C++ bindings readme](../carton-bindings-cpp/README.md) for more detail and diagrams.

## Integrating with external event systems/async code

The callback interface makes it easy to integrate with applications already using an event system like [libevent](https://libevent.org/) or [libuv](https://libuv.org/).

For example with libevent, users can handle Carton events in their existing event loop by creating [user triggered events](https://libevent.org/libevent-book/Ref4_event.html#_creating_user_triggered_events) in their Carton callbacks.